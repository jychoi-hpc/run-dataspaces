#!/usr/bin/env python

'''
This is a wrapper command for running dataspaces_server with multiple applications.

The general form of this comand is as follows:
$ stagerun.py SERVER_COMMAND [ : APPLICATION_COMMAND ] *

More details of options will be printed with '-h' option:
$ stagerun.py -h

For the most recent code, please check out here:
https://github.com/jychoi-hpc/stagerun
'''

import sys
import argparse
import subprocess
import os
import time
import logging
import copy
from threading  import Thread
from Queue import Queue, Empty

queue = Queue()
run_thread = False

def dequeue_output():
    while True:
        print queue.get()
        sys.stdout.flush()

def enqueue_output(out, prefix):
    if out is not None:
        while True:
            output = out.readline()
            if output:
                queue.put(prefix + output.rstrip())

def runthread(out, prefix):
    global run_thread
    if run_thread is False:
        t = Thread(target=dequeue_output)
        t.daemon = True
        t.start()
        run_thread = True
        
    t = Thread(target=enqueue_output, args=(out, prefix))
    t.daemon = True
    t.start()

def cmdlist(argv):
    '''
    return list of list
    '''
    cmds = list()
    _args = list()
    for x in argv:
        if x == ':':
            cmds.append(_args)
            _args = list()
        else:
            _args.append(x)

    cmds.append(_args)
    _args = list()

    return cmds

def getstds(args):
    if args.oe is None:
        f_stdout = open(args.stdout, 'w') if args.stdout is not None else subprocess.PIPE
        f_stderr = open(args.stderr, 'w') if args.stderr is not None else subprocess.PIPE
    else:
        f = open(args.oe, 'w')
        f_stdout = f
        f_stderr = f
    return (f_stdout, f_stderr)

def main():
    logging.basicConfig(level=logging.DEBUG, format='%(levelname)s: %(message)s')
    def usage():
        print ('USAGE: stagerun.py <SERVER_COMMAND> [ : <APP_COMMAND> ]*')
        print ('====================')
        parser_svr.print_help()
        print ('--------------------')
        parser_cmd.print_help()
        print ('--------------------')
        sys.exit()

    ##import ipdb; ipdb.set_trace()
    nserver = 0
    nclient = 0
    parser_svr = argparse.ArgumentParser(prog='SERVER_COMMAND', add_help=False)
    parser_svr.add_argument('--nserver', '-s', help='num. of servers', type=int, default=1)
    parser_svr.add_argument('--nclient', '-c', help='num. of clients (will overwrite estimated number)', type=int, default=0)
    parser_svr.add_argument('--mpicmd', help='mpi command', default='mpirun')
    parser_svr.add_argument('--opt', help='options for mpi command', action='append', default=[])
    parser_svr.add_argument('--stdout', '-o', help='stdout')
    parser_svr.add_argument('--stderr', '-e', help='stderr')
    parser_svr.add_argument('--oe', help='merging stdout and stderr')
    parser_svr.add_argument('--dryrun', help='dryrun', action='store_true')
    parser_svr.add_argument('--noserver', help='no server', action='store_true')
    parser_svr.add_argument('--sleep', help='sleep time between executions', type=int, default=3)
    parser_svr.add_argument('--serial', help='serial execution', action='store_true')

    parser_cmd = argparse.ArgumentParser(prog='APP_COMMAND', add_help=False)
    parser_cmd.add_argument('--np', '-n', help='num. of processes', type=int, default=1)
    parser_cmd.add_argument('CMDS', help='app commands', nargs=argparse.REMAINDER)
    parser_cmd.add_argument('--stdout', '-o', help='stdout')
    parser_cmd.add_argument('--stderr', '-e', help='stderr')
    parser_cmd.add_argument('--oe', help='merging stdout and stderr')
    parser_cmd.add_argument('--nompi', action='store_true', help='no mpi')
    parser_cmd.add_argument('--opt', help='options for mpi command', action='append', default=[])
    parser_cmd.add_argument('--cwd', help='work directory')
    parser_cmd.add_argument('--env', '-x', help='env key=value', action='append', default=[])
    parser_cmd.add_argument('--norun', help='no run', action='store_true')
    parser_cmd.add_argument('--prefix', help='stdout prefix')

    cmds = cmdlist(sys.argv[1:])
    if len(cmds) < 2:
        usage()

    args, _unknown = parser_svr.parse_known_args(cmds[0])
    nserver = args.nserver
    if len(_unknown) > 0:
        usage()

    args_cmd_list = list()
    for cmd in cmds[1:]:
        args_cmd, _unknown = parser_cmd.parse_known_args(cmd)
        setattr(args_cmd, 'UNKNOWN', _unknown)
        nclient += args_cmd.np
        args_cmd_list.append(args_cmd)

    if args.nclient > 0:
        nclient = args.nclient

    # Check config file and remove previous conf file
    if not args.noserver and not os.path.exists('dataspaces.conf'):
        logging.error('Error: no config file (dataspaces.conf). Exit.')
        sys.exit()

    os.remove('conf') if os.path.isfile('conf') else None

    # Run server
    ds_cmd = '%(mpicmd)s -n %(nserver)d %(opt)s dataspaces_server -s%(nserver)d -c%(nclient)d' % \
        {'mpicmd':args.mpicmd, 'opt':' '.join(args.opt), 'nserver':args.nserver, 'nclient':nclient}
    if not args.noserver:
        logging.debug('CMD: %s' % ds_cmd)

    plist = list()
    if not args.dryrun and not args.noserver:
        f_stdout, f_stderr = getstds(args)
        p = subprocess.Popen(ds_cmd.split(),
                stdout=f_stdout, stderr=f_stderr,
                close_fds=True)
        logging.debug('PID: %r (%r)' % (p.pid, ds_cmd))
        plist.append(p)

        prefix = '[%d]:'%p.pid
        runthread(p.stdout, prefix)
        runthread(p.stderr, prefix)

    env = os.environ.copy()
    if not args.dryrun and not args.noserver:
        while not os.path.exists('conf'):
            time.sleep(5)

        logging.debug('dataspaces_server is ready.')

        with open('conf') as f:
            lines = f.readlines()
            for ln in lines:
                try:
                    k, v = ln.rstrip('\n').split('=')
                    env[k] = v
                except:
                    pass

        logging.info('P2TNID=%s' % env['P2TNID'])
        logging.info('P2TPID=%s' % env['P2TPID'])

    # Run client
    for a in args_cmd_list:
        if not a.nompi:
            cl_cmd = ' '.join(['%(mpicmd)s -n %(np)d %(opt)s' % {'mpicmd':args.mpicmd, 'np':a.np, 'opt':' '.join(a.opt)}, ' '.join(a.UNKNOWN), ' '.join(a.CMDS)])
        else:
            cl_cmd = ' '.join([' '.join(a.CMDS)])

        logging.debug('CMD: %s' % cl_cmd)
        if not args.dryrun and not a.norun:
            if args.serial and len(plist)>0:
                p = plist.pop()
                logging.debug('Waiting PID: %r' % p.pid)
                p.wait()

            cl_env = copy.deepcopy(env)
            for kv in a.env:
                k, v = kv.split('=')
                cl_env[k] = v

            f_stdout, f_stderr = getstds(a)
            p = subprocess.Popen(cl_cmd.split(), env=cl_env,
                    stdout=f_stdout, stderr=f_stderr,
                    close_fds=True, cwd=a.cwd)
            logging.debug('PID: %r (%r)' % (p.pid, cl_cmd))
            plist.append(p)

            prefix = '[%d]:'%p.pid if a.prefix is None else a.prefix
            runthread(p.stdout, prefix)
            runthread(p.stderr, prefix)
            time.sleep(args.sleep)

    if not args.dryrun and len(plist)>0:
        for p in plist:
            logging.debug('Waiting PID: %r' % p.pid)
            p.wait()
    logging.info('Done.')

if __name__ == '__main__':
    main()
